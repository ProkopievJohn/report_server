import { ObjectId, Collection, Filter, FindOneAndUpdateOptions } from 'mongodb'
import {
	IsNotEmpty,
	IsOptional,
	IsEnum,
	IsString,
	IsEmail,
	IsBoolean,
	IsNumber,
	Min,
	IsArray,
} from 'class-validator'
import { db } from '.'
import { EHistoryActions, EUserRoles, EUserStatuses } from '../constants'
import { ExtractAutoGeneratedType, generateModifiedValue, validateModel } from '../utils/models'
import { ICollection, ICollectionState, IHistory } from './types'
import { CustomIsMongoId } from 'src/utils/validator'

export class IUser extends ICollectionState {
	@IsNotEmpty()
	@IsString()
	name: string

	@IsNotEmpty()
	@IsString()
	surname: string

	@IsNotEmpty()
	@IsEmail()
	email: string

	@IsOptional()
	@IsString()
	password?: string

	@IsNotEmpty()
	@IsNumber()
	@Min(0)
	rate: number

	@IsNotEmpty()
	@IsBoolean()
	emailVerified: boolean

	@IsNotEmpty()
	@CustomIsMongoId()
	companyId: ObjectId

	@IsNotEmpty()
	@IsEnum(EUserRoles)
	role: EUserRoles

	@IsNotEmpty()
	@IsEnum(EUserStatuses)
	status: EUserStatuses

	@IsNotEmpty()
	@IsArray()
	@CustomIsMongoId()
	abilities: ObjectId[]
}

export const collectionUserName = 'users'

export async function initUserCollection(): Promise<void> {
	const collection: Collection<IUser> = db.collection(collectionUserName)
	collection.createIndex({ email: 1, companyId: 1 }, { unique: true })
}

export const UserCollection: ICollection<IUser> = {
	async find(query: Filter<IUser>): Promise<IUser[]> {
		const collection: Collection<IUser> = db.collection(collectionUserName)
		return collection.find({
			$and: [
				query,
				{ status: { $ne: EUserStatuses.DELETED } },
			],
		}).toArray()
	},

	async findOne(query: Filter<IUser>): Promise<IUser> {
		const collection: Collection<IUser> = db.collection(collectionUserName)
		return collection.findOne({
			$and: [
				query,
				{ status: { $ne: EUserStatuses.DELETED } },
			],
		})
	},

	async aggregate(pipeline: Document[]): Promise<IUser[]> {
		const collection: Collection<IUser> = db.collection(collectionUserName)
		return collection.aggregate(pipeline).toArray()
	},

	async insertOne(doc: ExtractAutoGeneratedType<IUser>): Promise<IUser> {
		const history: IHistory = {
			createdAt: new Date(),
			action: EHistoryActions.CREATED,
			modifiedValues: generateModifiedValue({}, doc),
		}
		const newDoc: IUser = {
			...doc,
			createdAt: new Date(),
			updatedAt: new Date(),
			history: [history],
		}
		await validateModel(IUser, newDoc)

		const collection: Collection<IUser> = db.collection(collectionUserName)
		return await collection.findOne({ _id: (await collection.insertOne(newDoc)).insertedId })
	},

	async insertMany(docs: ExtractAutoGeneratedType<IUser>[]): Promise<IUser[]> {
		const newDocs: IUser[] = docs.map((doc: ExtractAutoGeneratedType<IUser>): IUser => {
			const history: IHistory = {
				createdAt: new Date(),
				action: EHistoryActions.CREATED,
				modifiedValues: generateModifiedValue({}, doc),
			}
			return {
				...doc,
				createdAt: new Date(),
				updatedAt: new Date(),
				history: [history],
			}
		})

		await Promise.all(newDocs.map(async (newDoc: IUser) => validateModel(IUser, newDoc)))

		const collection: Collection<IUser> = db.collection(collectionUserName)
		return await collection.find({
			...(await (collection.insertMany(newDocs))).insertedIds,
		}).toArray()
	},

	async update(doc: ExtractAutoGeneratedType<IUser>, options?: FindOneAndUpdateOptions): Promise<IUser> {
		const oldDoc = await this.findOne({ _id: doc._id })

		const history: IHistory = {
			createdAt: new Date(),
			action: EHistoryActions.MODIFIED,
			modifiedValues: generateModifiedValue(oldDoc, doc),
		}

		const newDoc: IUser = {
			...doc,
			createdAt: new Date(),
			updatedAt: new Date(),
			history: [history, ...oldDoc.history],
		}
		await validateModel(IUser, newDoc)

		const collection: Collection<IUser> = db.collection(collectionUserName)
		return (await collection.findOneAndUpdate(
			{
				_id: doc._id,
				status: { $ne: EUserStatuses.DELETED },
			},
			{ $set: newDoc },
			{
				returnDocument: 'after',
				...(options || {}),
			},
		)).value
	},

	async remove(query: Filter<IUser>): Promise<void> {
		const oldDoc = await this.findOne(query)

		const history: IHistory = {
			createdAt: new Date(),
			action: EHistoryActions.DELETED,
			modifiedValues: {
				status: EUserStatuses.DELETED,
			},
		}

		const collection: Collection<IUser> = db.collection(collectionUserName)
		await collection.updateOne(
			query,
			{
				$set: {
					email: `${oldDoc.email} - ${oldDoc._id.toString()}`,
					status: EUserStatuses.DELETED,
					updatedAt: new Date(),
					history: [history, ...oldDoc.history],
				},
			},
		)
	},

	async count(query: Filter<IUser>): Promise<number> {
		const collection: Collection<IUser> = db.collection(collectionUserName)
		return await collection.countDocuments({
			$and: [
				query,
				{ status: { $ne: EUserStatuses.DELETED } },
			],
		})
	},
}
