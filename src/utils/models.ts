import { ObjectId } from 'mongodb'
import { ClassConstructor } from 'class-transformer'
import { CaughtError, ExtractOmitType } from './helpers'
import { validateAndConvert, ValidateResponse } from './validator'

export async function validateModel<C, D>(ClassToConvert: ClassConstructor<C>, doc: D): Promise<void | CaughtError> {
	const errors: boolean | ValidateResponse = await validateAndConvert(ClassToConvert, doc)

	if (errors) {
		const validateResponse = errors as ValidateResponse
		throw new CaughtError('Not valid insert data.', validateResponse)
	}
}

const skipKeys: string[] = ['_id', 'createdAt', 'updatedAt', 'history']
type TSkipKeys = '_id' | 'createdAt' | 'updatedAt' | 'history'

export type ExtractAutoGeneratedType<T> = ExtractOmitType<T, TSkipKeys> & Partial<T>

function isArraysEqual(before: unknown[], after: unknown[]): boolean {
	return after.length === before.length && after.every((o, idx) => isEqual(before[idx], o))
}

function isObjectsEqual(before: Record<string, unknown>, after: Record<string, unknown>): boolean {
	return Object.keys(after).length > 0
		&& Object.keys(before).length === Object.keys(after).length
		&& Object.keys(after).every(p => {
			return JSON.stringify(before[p]) === JSON.stringify(after[p])
		})
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEqual(before: any, after: any): boolean {
	if (Array.isArray(after)) {
		return isArraysEqual(before || [], after)
	}
	if (after instanceof Date) {
		return !!before && after.toISOString() === before.toISOString()
	}
	if (after instanceof Object) {
		return isObjectsEqual(before || {}, after)
	}
	return before === after
}

function isNotContain(field: unknown, arr: unknown[]): boolean {
	return arr.every(item => !isEqual(field, item))
}

export function generateModifiedValue(before: Record<string, unknown | string | number | ObjectId>, after: Record<string, unknown | string | number | ObjectId>): Record<string, unknown> {
	return Object.keys(after).reduce((acc: Record<string, unknown>, key: string) => {
		if (skipKeys.includes(key)) {
			return acc
		}
		if (key === 'password' && before[key] !== after[key]) {
			acc.newPassword = true
			return acc
		}
		if (typeof after[key] === 'string' && before[key] !== after[key]) {
			acc[key] = after[key]
			return acc
		}
		if (ObjectId.isValid(after[key] as ObjectId | string) && (!before[key] || before[key].toString() !== after[key].toString())) {
			acc[key] = after[key].toString()
			return acc
		}
		if (Array.isArray(after[key])) {
			if ((!before[key] || !(before[key] as Array<unknown>).length) && !(after[key] as Array<unknown>).length) {
				return acc
			}
			acc[key] = {
				new: (after[key] as Array<unknown>).filter((afterField: unknown) => isNotContain(afterField, (before[key] as Array<unknown> || []))),
				prev: (before[key] as Array<unknown> || []).filter((beforeField: unknown) => isNotContain(beforeField, (after[key] as Array<unknown>))),
			}
			return acc
		}
		if (!isEqual(before[key], after[key])) {
			acc[key] = after[key]
		}
		return acc
	}, {})
}
