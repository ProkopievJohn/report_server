import { Collection, Filter, Document, FindOneAndUpdateOptions } from 'mongodb'
import {
	IsNotEmpty,
	IsEnum,
	IsString,
} from 'class-validator'
import { db } from '.'
import { ECompanyStatuses, EHistoryActions } from '../constants'
import { ExtractAutoGeneratedType, generateModifiedValue, validateModel } from '../utils/models'
import { ICollection, ICollectionState, IHistory } from './types'

export class ICompany extends ICollectionState {
	@IsNotEmpty()
	@IsString()
	name: string

	@IsNotEmpty()
	@IsEnum(ECompanyStatuses)
	status: ECompanyStatuses
}

export const collectionCompanyName = 'companies'

export async function initCompanyCollection(): Promise<void> {
	const collection: Collection<ICompany> = db.collection(collectionCompanyName)
	collection.createIndex({ name: 1 }, { unique: true })
}

export const CompanyCollection: ICollection<ICompany> = {
	async find(query: Filter<ICompany>): Promise<ICompany[]> {
		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return collection.find({
			$and: [
				query,
				{ status: { $ne: ECompanyStatuses.DELETED } },
			],
		}).toArray()
	},

	async findOne(query: Filter<ICompany>): Promise<ICompany> {
		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return collection.findOne({
			$and: [
				query,
				{ status: { $ne: ECompanyStatuses.DELETED } },
			],
		})
	},

	async aggregate(pipeline: Document[]): Promise<ICompany[]> {
		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return collection.aggregate(pipeline).toArray()
	},

	async insertOne(doc: ExtractAutoGeneratedType<ICompany>): Promise<ICompany> {
		const history: IHistory = {
			createdAt: new Date(),
			action: EHistoryActions.CREATED,
			modifiedValues: generateModifiedValue({}, doc),
		}
		const newDoc: ICompany = {
			...doc,
			createdAt: new Date(),
			updatedAt: new Date(),
			history: [history],
		}
		await validateModel(ICompany, newDoc)

		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return await collection.findOne({ _id: (await collection.insertOne(newDoc)).insertedId })
	},

	async insertMany(docs: ExtractAutoGeneratedType<ICompany>[]): Promise<ICompany[]> {
		const newDocs: ICompany[] = docs.map((doc: ExtractAutoGeneratedType<ICompany>): ICompany => {
			const history: IHistory = {
				createdAt: new Date(),
				action: EHistoryActions.CREATED,
				modifiedValues: generateModifiedValue({}, doc),
			}
			return {
				...doc,
				createdAt: new Date(),
				updatedAt: new Date(),
				history: [history],
			}
		})

		await Promise.all(newDocs.map(async (newDoc: ICompany) => validateModel(ICompany, newDoc)))

		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return await collection.find({
			...(await (collection.insertMany(newDocs))).insertedIds,
		}).toArray()
	},

	async update(doc: ExtractAutoGeneratedType<ICompany>, options?: FindOneAndUpdateOptions): Promise<ICompany> {
		const oldDoc = await this.findOne({ _id: doc._id })

		const history: IHistory = {
			createdAt: new Date(),
			action: EHistoryActions.MODIFIED,
			modifiedValues: generateModifiedValue(oldDoc, doc),
		}

		const newDoc: ICompany = {
			...doc,
			createdAt: new Date(),
			updatedAt: new Date(),
			history: [...oldDoc.history, history],
		}
		await validateModel(ICompany, newDoc)

		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return (await collection.findOneAndUpdate(
			{
				_id: doc._id,
				status: { $ne: ECompanyStatuses.DELETED },
			},
			{ $set: newDoc },
			{
				returnDocument: 'after',
				...(options || {}),
			},
		)).value
	},

	async remove(query: Filter<ICompany>): Promise<void> {
		const oldDoc = await this.findOne(query)

		const history: IHistory = {
			createdAt: new Date(),
			action: EHistoryActions.DELETED,
			modifiedValues: {
				status: ECompanyStatuses.DELETED,
			},
		}
		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		await collection.updateOne(
			query,
			{
				$set: {
					name: `${oldDoc.name} - ${oldDoc._id.toString()}`,
					status: ECompanyStatuses.DELETED,
					updatedAt: new Date(),
					history: [...oldDoc.history, history],
				},
			},
		)
	},

	async count(query: Filter<ICompany>): Promise<number> {
		const collection: Collection<ICompany> = db.collection(collectionCompanyName)
		return await collection.countDocuments({
			$and: [
				query,
				{ status: { $ne: ECompanyStatuses.DELETED } },
			],
		})
	},
}
